# -*- coding: utf-8 -*-
"""
Created on Wed May 04 08:00:00 2022

@author: Eric
"""
#______________________________________________________________________________ Dependencies and hard-coded variables.

## Importing necessary libraries.

from Bio import SeqIO                                                           # bipython needs to be installed: 
from Bio import AlignIO                                                         # http://biopython.org/DIST/docs/tutorial/Tutorial.html
from Bio import pairwise2                                                       # For reading .fastq and .fasta files; handling objects as seqs; aligning.

import gzip                                                                     # For unzipping the .gz files from the NGS facility in batch.
import shutil                                                                   # For unzipping the .gz files from the NGS facility in batch.
import os                                                                       # For automatically pairing datafiles with sample names.
import pandas as pd                                                             # For tallying the slices and analyzing the tallies.
import tkinter as tk                                                            # For creating the GUI. 

import time                                                                     # For reporting the time various processing steps take.

t0 = time.time()                                                                # Get the time at the start of the program.


## Hard coding user inputs for testing/development. Gets overwritten by user
## inputs.

if os.name == 'posix':                                                          # Set the file path separator to '/' for Unix environments.
    os_slash = '/'
elif os.name == 'nt':                                                           # Set the file path separator to '\\' for Windows environments.
    os_slash = '\\'
else:                                                                           # Throw an error if the program is being run on an unsupported operating system.
    input('\nThis is not a supported operating system. Press ENTER to quit.')
    quit()

# input_directory = r'' + os_slash                                              # Directory for the template file and data files. 
template_file = r'Template_sequences.csv'                                       # Name of the file containing sample names and template sequences.

blank = 'GG-107-nb02'                                                           # Name of the sample to be used as a blank in the final analysis. 

tidy_mode = 1                                                                   # 'Tidy mode' (delete files after the program is done with them) is off by default.

extract_winners = 0                                                             # Determine if analysis should be performed automatically.
                                                                                # Set to -1 to go by user input; set to 1 for yes; set to 0 for no. 
number_of_winners = 10                                                          # Default number of winning sequences to report. 


#______________________________________________________________________________ User inputs. Comment out during testing/development.

## Taking user inputs.

# all_user_inputs = {}                                                          # Creates an empty dict of all user inputs. 

# print('Put all your data (.gz) files and your file of template sequences \
# (Template_sequences.csv) into one folder.')                                   # Tell the user to put everything in their input directory.
# p = str(input('Enter the file path of the folder your data is in:\n'))        # Set the file path the user inputs as the input directory.
# input_directory = p + os_slash
# all_user_inputs['Input directory'] = input_directory                          # Records input directory for log.

# tidy_mode = int(input('\nDo you want to run this program in \'Tidy Mode\'?\n\
# - No, I want to keep the large intermediate files that are generated by \
# this program, even though they can take up A LOT of space, enter: 0\n\
# - Yes, delete intermediate files after use to save drive space \
# (recommended), enter: 1\n\nYour answer: '))                                   # Ask the user if they want to exit Tidy Mode (see above).

# if tidy_mode == 0:                                                            # Screens for the user's input about Tidy Mode.
#     tidy_mode = 0                                                             # If the user gave a valid input, it keeps that value.
#     all_user_inputs['Tidy mode'] = 'No'                                       # Records tidy mode status for log.
# elif tidy_mode == 1:
#     tidy_mode = 1
#     all_user_inputs['Tidy mode'] = 'Yes'                                      # Records tidy mode status for log.
# else:
#     print('You have pressed an incorrect key; please restart the program.')   # If it's not a valid input, it asks the user to restart the whole program.

# if extract_winners == -1:
#     extract_winners = int(input('Do you want to normalize, blank subtract,\
# and rank the winning sequences automatically now?\n\
# - No, I will do this manually later, enter: 0\n\
# - Yes, please perform analysis automatically, enter: 1\n\nYour answer: '))
#     if extract_winners == 0:                                                  # Screens for the user's input about Tidy Mode.
#        extract_winners == 0                                                   # If the user gave a valid input, it keeps that value.
#        all_user_inputs['Extract winners'] = 'No'                              # Records tidy mode status for log.
#     elif extract_winners == 1:
#        extract_winners == 1
#        all_user_inputs['Extract winners'] = 'Yes'                             # Records tidy mode status for log.
#     else:                                                                     # If it's not a valid input, it asks the user to restart the whole program.
#        print('You have pressed an incorrect key; please restart the program.')  

# if extract_winners == 1:                                                      # Checks if the user wants the analysis step to be performed.
#     number_of_winners = int(input('\nHow many winners would you like to \
# get back?\n\nYour answer: '))                                                 # Sets how many of the top sequences to write to the .txt file.
#     all_user_inputs['Winners to display'] = number_of_winners                 # Records tidy mode status for log.

# if os.path.exists(input_directory + template_file):                           # Checks that Template_sequences.csv is in the working directory.
#     1+1                                                                       # Continues with the rest of the program if it is.
# else:
#     input('It looks like you forgot to include "Template_sequences.csv" in \
# your file directory (or maybe you renamed it?). Please fix this, then press \
# ENTER to continue. I\'ll wait.')                                              # Alerts the user if Template_sequences.csv is not in the proper location.
#     while os.path.exists(input_directory + template_file) == False:
#         input('I still can\'t find "Template_sequences.csv" in the file \
# directory you entered. Please check the following and press ENTER again:\
#     - The file is named "Template_sequences", (including capitalization)\n\
#     - The file is of the ".csv" format\n\
#     - The file is in the folder you listed as the input directory: ' +
#     input_directory)                                                          # Gives the user infinite retries if they didn't get it right the first time.
        
# print('\nThis may take a few hours, depending on the number/size of files.\n')# Give a ballpark for how long the program will take to run.

window = tk.Tk()                                                                # Initializes a GUI for inputting information for running the program. 
window.title('Hognose 0.0.27')                                                  # Displays the current version of the program. 

def fxn_tidy():
    global tidy_mode                                                            # Gives the value of tidy_mode assigned within this function global scope.
    if btn_tidy.config('text')[-1] == 'Tidy mode is ON':                        # Check if tidy mode is set to "ON".
        btn_tidy['text'] = 'Tidy mode is OFF'                                   # If it is, change the label to "OFF"...
        tidy_mode = 0                                                           # ...and adjust the variable tidy_mode accordingly.
    else:
        btn_tidy['text'] = 'Tidy mode is ON'                                    # If it isn't, change the label to "ON"...
        tidy_mode = 1                                                           # ...and adjust the variable tidy_mode accordingly.
        
def fxn_analysis():
    global extract_winners                                                      # Gives the value of extract_winners assigned within this function global scope.
    if btn_analysis.config('text')[-1] == 'Automatic Analysis is ON':           # Checks if the automatic analysis button is set to "ON".
        btn_analysis['text'] = 'Automatic Analysis is OFF'                      # If it is, change the label to "OFF"...
        extract_winners = 0                                                     # ...and adjust the variable extract_winners accordingly.
    else:
        btn_analysis['text'] = 'Automatic Analysis is ON'                       # If it isn't, change the label to "ON"...
        extract_winners = 1                                                     # ...and adjust the variable extract_winners accordingly.
        
def fxn_submit():
    global input_directory                                                      # Gives the value of input_directory assigned within this function global scope.
    input_directory = directory_var.get() + os_slash                            # Defines input_directory as the file path the user inputs formatted to suit their os. 
    ent_directory.delete(0, tk.END)
    all_user_inputs = 'Input directory: ' + input_directory + '\n' \
    + str(btn_tidy['text']) + '\n' + str(btn_analysis['text']) + '\n'           # Formats the settings for this particular run as a readable string. 
    window.destroy()                                                            # Close the GUI dialog.
    
def fxn_cancel():
    window.destroy()                                                            # Close the GUI dialog.
    raise SystemExit                                                            # End the main program.                                                          
    
def fxn_exit():
    exit_window.destroy()                                                       # Close the GUI dialog.
    raise SystemExit                                                            # End the main program. 
    
frame_10 = tk.Frame(master=window, width=900, height=90)                        # Formatting the frame for the GUI buttons.
frame_20 = tk.Frame(master=window, width=800, height=500)                       # Formatting the frame for the GUI instructions.

directory_var = tk.StringVar()                                                  # Allows the input directory the user inputs (through the GUI) to be taken as a variable.
all_user_inputs = ''                                                            # Empty string that will contain the settings for that particular run.

lbl_directory = tk.Label(text='Input Directory:', master=frame_10)              # Label asking for the input directory. 
lbl_directory.place(x = 5, y = 5)

ent_directory = tk.Entry(textvariable = directory_var, master=frame_10, 
                         width=120)                                             # Entry for the user to paste the input directory. 
ent_directory.place(x = 100, y = 5)

btn_submit = tk.Button(master=frame_10, text='Submit', command=fxn_submit)      # Button to submit the current settings and start the rest of the program. 
btn_submit.place(x = 5, y = 50)

btn_tidy = tk.Button(master=frame_10, text="Tidy mode is ON", command=fxn_tidy) # ON/OFF button for tidy mode.
btn_tidy.place(x = 205, y = 50)

btn_analysis = tk.Button(master=frame_10, text="Automated Analysis is OFF", 
                         command=fxn_analysis)                                  # ON/OFF button for automated analysis mode.
btn_analysis.place(x = 405, y = 50)

btn_cancel = tk.Button(master=frame_10, text="Cancel", command=fxn_cancel)      # Create a cancel button at the left.
btn_cancel.place(x = 605, y = 50)

lbl_instructions = tk.Label(text='\
1. Put all your data (.gz) files and your file of template sequences \
(Template_sequences.csv) into one folder.\n\n\
2. Fill out Template_sequences.csv with your sample names and their template \
sequences. Remember the following:\n\
    - Sample names should be the exact names you sent to the facility that \
performed your sequencing, otherwise these files will be ignored.\n\
    - You must replace any positions of interest in your template sequences \
with a capital "N", otherwise these positions will not be monitored.\n\
    - Do not skip rows before or between sample entries.\n\
    - Do not rename Template_sequences.csv or any of the column headers.\n\
\n\
3. Copy the file path into the box labelled "Input Directory:"\n\n\
4. Do you want to run the program in Tidy Mode?\n\n\
    - ON: The program will delete temporary files after use to save drive \
space (recommended)\n\n\
    - OFF: The program will keep the temporary files that are \
generated by this program. WARNING: This can take up A LOT of space.\n\n\
5. Do you want to normalize, blank subtract, and rank the winning sequences \
automatically now?\n\n\
    - ON: Be sure to indicate which sequences will serve as blanks by \
typing "yes" in the "blank" column of Template_sequences.csv for that \
sample. NOTE: Do not mark any samples as blanks without confirming that their \
data files are in the input directory, as this will cause an error.\n\n\
    - OFF: You will still be able to access the raw data for manual analysis \
in "Hognose Results.csv" once the program is complete.\n\n\
6. Click "Submit" to close this window and let the program begin.\n\n\
7. Monitor the console for Errors and warnings. Refer to the ReadMe document \
as needed.\n\n\
8. Collect the raw ("Hognose Results.csv") and/or ranked (Winners.txt) data.',
master=frame_20, anchor = 'e', justify=tk.LEFT)                                 # Instructions for user.
lbl_instructions.place(x = 5, y = 5)

frame_10.pack()                                                                 # Add the buttons to the top of the GUI window. 
frame_20.pack(side=tk.LEFT)                                                     # Add the instructions to the bottom. 

window.mainloop()                                                               # Adds the input window to run as part of the program.

#______________________________________________________________________________ Error checking: Input directory

entry_stage = True
while entry_stage:
    if os.path.exists(input_directory) == False:                                # Checks that the input directory is a valid file path.
        input('Unable to access the input directory. Please try again or use \
a different file location first.\nInput directory: ')                           # Throws an error if this is not the case.
    if os.path.exists(input_directory + template_file) == False:                # Checks that the template file is in the input directory.
        input('Unable to find Template_sequences.csv. Please ensure it is in \
the input directory and has not been renamed.\nInput directory: ')              # Throws an error if this is not the case.
    for fname in os.listdir(input_directory):                                   # Checks if there are any files that are compatible with the program in input directory.
        if fname.endswith('.fastq.gz') or fname.endswith('.fastq') or \
        fname.endswith('-hq.fasta') or fname.endswith('-aligned.txt') or \
        fname.endswith('_sliced.txt') or fname.endswith('RunLog.txt') or \
        fname.endswith('Results.csv'):
            break                                                               # Breaks out of the loop if at least one compatible file is found. 
    else:
         input('No properly formatted data files in input directory. Please \
ensure the file location is correct.\nInput directory: ')                       # Throws an error if this is not the case.
    
    entry_stage = False                                                         # If none of the screening errors are triggered, the program commences.         

t1 = time.time()                                                                # Records the current time after use inputs are complete. 


#______________________________________________________________________________ Template_seqeunces.csv

## Create a dictionary of sample names (keys) and template sequences (values)
## from the template file. 

templates = pd.read_csv(input_directory + template_file)                        # Reads the contents of the template file.
d_templates = {}                                                                # Creates an empty dictionary to be filled by samples (keys) and templates (values).
blanks = []                                                                     # Creates an empty list to be filled with samples for enrichment to be blanked against.

for template, row in templates.iterrows():                                      # Iterates through each row of the template file.
    l = row['sample_name']                                                      # Grabs the sample name from a particular row.
    m = row['template_sequence']                                                # Grabs the template sequence corresponding to that sample.

    # if len(m) <= 150:                                                           # You may need to uncomment this if your templates are longer than 
    #     continue                                                                # the lengths of the reads (150 nt). I'm not sure if this actually makes difference.
    # else:                                                                     # !!NOTE: If you don't need this uncommented, don't use it!
    #     m = m[:150]                                                           # It broke the code for a little while and I'm not sure why. 
        
    d_templates[l] = str(m)                                                     # Assigns each sample name and template as a key-value pair in a dictionary.
    o = row['blank']                                                            # Checks if samples are to be used as blanks.
    if str(o).lower() == 'yes':                                                 # If a sample is to be used as a blank...
        blanks.append(str(l))                                                   # ...append it's name to the list of files to be used as blanks.
    else:                                                                       # Else, skip that sample.
        continue


#______________________________________________________________________________ Error checking: Template_sequences.csv.

template_stage = True
while template_stage:
    if len(d_templates) == 0:                                                   # Checks that sample names and sequences have been given in Template_sequences.csv.
        input('Unable to find any templates in Template_sequences.csv. Please \
check that your sample names and template sequences have been added and press \
"Enter".')                                                                      # Throws an error if this is not the case.
    if extract_winners == 1 and len(blanks) < 1:                                # Checks that sequences have been designated as blanks if in Automated Analysis mode.
        input('Automated Analysis mode has been selected, but no sequences in \
Template_sequences.csv have been designated as blanks. Please correct this \
and press "Enter".')                                                            # Throws an error if this is not the case.

    template_stage = False                                                      # If none of the screening errors are triggered, the program commences.

#______________________________________________________________________________ Functions used throughout the code.

## Setting up a log file.

def runlog(string, directory):
    with open(str(directory) + 'Hognose RunLog.txt', 'a') as f_out:             # Creates .txt file to which console messages will be written. 
        f_out.writelines(string)                                                # Writes the console message to the log file.
        print(string)                                                           # Prints the message in the console. 


## Unzips all the .gz files in a directory and deletes them afterward.

def gz_unzip(input_directory):
    os.chdir(input_directory)                                                   # Sets current working directory to the user-specified input_directory.
    for item in os.listdir(input_directory):                                    # Loops through each file in the directory.
        if item.endswith(".gz"):                                                # Items items with the .gz extension get extracted to a file with the 
            with gzip.open(input_directory + item, 'rb') as f_in:               # same name (without the .gz extension).
                with open((os.path.basename(item)).rsplit('.',1)[0], 'wb')\
                    as f_out:
                    shutil.copyfileobj(f_in, f_out)

#### Uncomment this block if you want the program to delete .gz files as well.
#### This was written before the introduction of tidy mode, and was removed to
#### prevent people from accidentally deleting all their raw data. 
    # if tidy_mode == 1:                                                        # Checks if Tidy Mode is activated. 
    #     for item in os.listdir(input_directory):                              # Loop back through the directory and delete any remaining .gz files. 
    #         if item.endswith(".gz"):
    #             os.remove(item)


## Yields reads of sufficiently high quality from raw data (.fastq) files.      # Inspired by the last answer on this page:
                                                                                # https://www.biostars.org/p/100281/
def qual_screen(data_file):
    def qual_filter(template, data_file):
        error_cutoff = len(template) // 10                                      # Max allowable bases per read (10%) below the quality threshold.
        for record in SeqIO.parse(data_file, 'fastq'):                          # Iterate through sequences in .fastq file.
            read_qualities = record[0:len(template)].letter_annotations         # Creates list of quality scores as long as the template.
            error_count = 0                                                     # Resets the error count for each read.
            for i, q in enumerate(read_qualities['phred_quality']):             # For each position in the sequence (i), check the quality score (q).
                if q < 20:
                    error_count += 1                                            # Tally the positions that fall below the quality threshold.
            if error_count > error_cutoff:                                      # If that read has too many low-quality bases, move on.
                continue
            else:                                                               # If the read passes quality control, output the read. 
                yield record[0:len(template)]
    
    template = d_templates[item.rsplit('_',4)[0]]                               # Find the template corresponding to that .fastq file.
    if item.rsplit('_',4)[3] == 'R1':                                           # Check if the file is for a forward read. 
        with open(input_directory + item, 'r') as f_in:
            data = os.path.basename(item)                                       # Use the .fastq file as the source of data.
            qual_filtered = qual_filter(template, data)                         # Call the qual_filter function to pass on the high-quality reads.
            count = SeqIO.write(qual_filtered,                                  # Write the high-quality reads in .fasta format to a .fasta file. 
                (os.path.basename(item)).rsplit('_',4)[0] + '_Fwd-hq.fasta', 
                'fasta') 
            runlog(item + ': ' + str(count) + ' reads passed for quality\n', 
                   input_directory)                                             # Print the number of reads that passed the quality test. 
    elif item.rsplit('_',4)[3] == 'R2':                                         # Check if the file is for a reverse read.
        with open(input_directory + item, 'r') as f_in:                         # Perform the same operations as for the forward read. 
            data = os.path.basename(item)
            qual_filtered = qual_filter(template, data)
            count = SeqIO.write(qual_filtered,
                (os.path.basename(item)).rsplit('_',4)[0]
                + '_Rev-hq.fasta', 'fasta')
            runlog(item + ': ' + str(count) + \
                   ' reads passed for quality\n', input_directory)


def alignment(data_file):
    template = d_templates[item.rsplit('_',1)[0]]                               # Determines which template sequence to compare the reads to.
    fasta = AlignIO.read(item, "fasta")                                         # Read through the .fasta files for alignments in fasta format. 
    if item.endswith('_Fwd-hq.fasta'):                                          # Checks if the file represents forward reads.
        with open((os.path.basename(item)).rsplit('_',1)[0]                     # Create a .txt file for storing the alignments.
                  + '_Fwd-aligned.txt', 'w') as f_aligned:
            for record in fasta:                                                # Loop through each sequence in the .fasta file. 
                alignment = pairwise2.align.globalms(template, record.seq,      # Aligns the forward read to the template.
                     2, -0.1, -1.5, -0.5, one_alignment_only=True)              # Sequence alignment parameters. Default should be 2, -0.1, -1.5, -0.5.
                f_aligned.writelines(str(alignment) + "\n")                     # Writes each new alignment to the .txt file of alignments as a new line.
    elif item.endswith('_Rev-hq.fasta'):                                        # Checks if the file represents reverse reads.
        with open((os.path.basename(item)).rsplit('_',1)[0]                     # Create a .txt file for storing the alignments.
                  + '_Rev-aligned.txt', 'w') as f_aligned:
            for record in fasta:                                                # Loop through each sequence in the .fasta file.
                q = record.seq                                                  # Converts strings representing the sequences into seq objects.
                r = q.reverse_complement()                                      # Gets the reverse complement of the sequence for that read. 
                alignment = pairwise2.align.globalms(template, r,               # Aligns the RC of the reverse read to the template.
                     2, -0.1, -1.5, -0.5, one_alignment_only=True)              # Sequence alignment parameters. Default should be 2, -0.1, -1.5, -0.5.
                f_aligned.writelines(str(alignment) + "\n")                     # Writes each new alignment to the .txt file of alignments as a new line.
    t3 = time.time()
    runlog(item + ' has been aligned. ' + str(t3-t1) +
           ' seconds elapsed.\n', input_directory)
    
    
def slicing(data_file):
    template = d_templates[item.rsplit('_',1)[0]]                               # Determines which template sequence to compare the reads to.
    with open((os.path.basename(item)), 'r') as f_in, \
        open((os.path.basename(item)).rsplit('_',1)[0]                          # Creates an empty .txt file to APPEND slices form both reads to.
        + '_sliced.txt', 'a') as f_out:   
        total_alignments = 0                                                    # Creates a tally of how many alignments get read.
        failed_alignments = 0                                                   # Creates a tally of how many alignments fail.
        for i in f_in:                                                          # Iterates through all alignments in the file.
            total_alignments += 1                                               # Increment the total number of alignments that have been read. 
            h = str(i).split(',')                                               # Generates a temporary list to hold each alignment.
            seqA = h[0]                                                         # Get the template sequence from this alignment.
            seqB = h[1]                                                         # Get the read sequence from this alignment. 
            aligned_N = ''                                                      # Generate an empty string that will be populated with the slice for that alignment.
            for j in range(17, len(seqA)):                                      # Loop through each position in the template, skipping the metadata and excess bases.
                if seqA[j] == 'N':                                              # Check if the position in the template is an 'N'.
                    if seqB[j-10] == '-':                                       # Check if the corresponding position in the read sequence is aligned as a gap.
                        failed_alignments += 1                                  # If it is, increment the tally of failed alignments and move to the next alignment.
                        break
                    elif seqB[j-10] in bases:                                   # Check if the read position aligned with N in the template is a canonical base.
                        aligned_N = aligned_N + seqB[j-10]                      # If it is, append it to the string of slices.
                    else:                                                       # If it's not, print an error and continue. 
                        runlog('Non-ATCG base (' + seqB[j-10] + ') in '
                          + item + ' at position ' + str(j) + ' of read '
                          + str(total_alignments) + '\n', input_directory)
            if len(aligned_N) == len_n_by_value[template]:                      # Check that the string containing the slice represents the correct number of positions.
                f_out.writelines(aligned_N + '\n')                              # Write correct slices to the .txt file of slices.
            else:                                                               # Skip incorrect slices. 
                continue
    runlog(item + ': %i passed alignments out of %i total.\n'                   # Print the number of passed alignments and the total alignments per .fasta file.
         % (total_alignments - failed_alignments, total_alignments),
             input_directory)


## Exports the winning sequences from the tidy rankings of slices.

def export_winners(input_directory, results_file, number_of_winners):    
    df = pd.read_csv(results_file)                                              # Opens the file containing the enrichment results as a dataframe.
    sample_list = pd.unique(df['sample name'])                                  # Turns all unique values in the "sample name" column into a list.
    
    df_wide = df.pivot_table(index='slice', columns='sample name',
                             values='tally')                                    # Creates a dataframe indexed by the slice of the sequence.
    df_wide = df_wide.reset_index()                                             # Changes the dataframe to the default index.
    
    sums = {}                                                                   # Creates an empty dictionary to be filled by total reads per sample.
    for blank in blanks:                                                        # Iterates through list of samples to be blanked against.
        for i in df_wide:                                                       # Iterates through the column headers of the dataframe.
            if i in sample_list:                                                # If the header represents a column of tallies for a sample.
                sums[i] = df_wide[i].sum()                                      # If it does, sum all tallies of that column.
        with open(input_directory + 'Winners-subtracted_' + blank + '.txt',\
                    'w') as f_out:                                              # Opens an empty text file to be filled with blank-subtracted data.
            for i in sample_list:                                               # Iterates through sample list.
                df_wide[i + '%'] = df_wide[i] * 100 / sums[i]                   # Calculates the %enrichment for each slice.
            for i in sample_list:                                               # Iterates through sample list.
                print(df_wide)
                df_wide[i + '_blanked'] = df_wide[i + '%'] - df_wide[str(blank) + '%']                                   # Performs blank subtraction for %enrichment.
                j = ['slice', i + '_blanked']                                   # Location in dataframe of blank-subtracted enrichment data.
                f_out.writelines(i + ' ranked:\n' + \
                    str(df_wide[j].nlargest(number_of_winners, i + '_blanked'))
                    + '\n\n')                                                   # Writes the top blank-subtracted sequences to the output file.


#______________________________________________________________________________ Body of code.

runlog(('New instance initiated at ' + time.asctime(time.localtime(t0)) +
        '.\n' + ('-' * 60) + '\n'), input_directory)                            # Records the date and time at which the program is started. 
runlog('User inputs:\n' + all_user_inputs, input_directory)                     # Records the user's inputs in the RunLog file.


## Identifying the N positions in the template.

bases = ["A", "C", "G", "T", "U"]                                               # Sets the list of acceptable bases for template sequences.
template_keys = []                                                              # Empty list to be filled with sample names.
template_values = []                                                            # Empty list to be filled with template sequences.
len_n_by_key = {}                                                               # Empty dictionary to be filled with sample names and lengths of N regions.
len_n_by_value = {}                                                             # Empty dictionary to be filled with template sequences and lengths of N regions.
for j, (key, value) in enumerate(d_templates.items()):                          # Loop through each item in the dictionary of samples and their templates.
    template_keys.append(key)                                                   # Add the current sampe name (key) to the list of sample names.
    template_values.append(d_templates[key])                                    # Add the current template sequence (value) to the list of template sequences.
    i = 0                                                                       # Counter for tracking the current position along each template sequence.
    n = []                                                                      # Empty list to be filled with N positions.
    for l in value:                                                             # Iterate through each base of the template sequence.
        if l == "N":                                                            # Check if the current position is an "N".
            n.append(i)                                                         # If it is, add its position to the list of N positions.
            i = i + 1                                                           # Increment the current base.
        elif l in bases:                                                        # Check if the position is one of the canonical bases.
            i = i + 1                                                           # If it is, iterate the current position and move on.
            continue
        else:                                                                   # If the current position in the template reads as some other value,
            runlog('Erroneous residue at position ' + str(i) + ': ' + l +'\n',
                   input_directory)                                             # throw an error and end the program. 
            i = i + 1
            break
    runlog(str(key) + ' will be monitored at positions: ' + str(n) + '\n',
           input_directory)                                                     # Print the positions that will be monitored. 
    len_n_by_key[key] = len(n)                                                  # Record the number of N positions (value) for that sample (key) in a dictionary.
    len_n_by_value[value] = len(n)                                              # Record the number of N positions (value) for that template (key) in a dictionary.

valid_samples = []                                                              # Creates an empty list of samples that are in Template_sequences.csv and the input direcotry.

print("Please wait while the .gz files are unzipped.")


## Extracting the .fastq files from the downloaded .gz files. Relatively quick.

gz_unzip(input_directory)

t2 = time.time()                                                                # Get current time.
runlog('\ngunzip complete:' + str(t2-t1) + 'seconds elapsed.\n',
       input_directory)                                                         # Print the elapsed time up to this point. 


## Write sequences with sufficient read quality to .fasta files for 
## alignment.

runlog('\nQuality screen:\n', input_directory)                                  # Alert the user to the current phase of the analysis.

for item in os.listdir(input_directory):                                        # Loop through each file in the specified directory.
    if item.endswith('.fastq'):                                                 # Check if the file is a fastq file.
        if item.rsplit('_',4)[0] in d_templates:                                # Check if there is a template sequence assigned for the data file.
            qual_screen(item)                                                   # Filter out low-quality reads. 
        else:
            runlog('No template in Template_sequences.csv for ' + item + 
                   '. Skipping over this file.\n', input_directory)             # Ignore files that do not have templates assigned in Template_sequences.csv and alert the user to this. 

if tidy_mode == 1:                                                              # Checks if Tidy Mode is activated. 
    for item in os.listdir(input_directory):                                    # Loop back through the directory and delete any remaining .fastq files. 
        if item.endswith(".fastq"):
            os.remove(item) 
    
t2 = time.time()                                                                # Get current time.
runlog('\nQuality screen complete:' + str(t2-t1) + 'seconds elapsed.\n',
       input_directory)                                                         # Print the elapsed time up to this point. 


## Aligning the sequences to their templates. This is the slowest step.

runlog('\nAlignment:\n', input_directory)                                       # Alert the user to the current phase of the analysis.

for item in os.listdir(input_directory):                                        # Loop through each file in the specified directory.
    if item.endswith('-hq.fasta'):                                              # Check for .fasta files of sequences that have passed the quality test.
        if item.rsplit('_',2)[0] in d_templates:                                # Check if there is a template sequence assigned for the data file
            alignment(item)
        else:
            runlog('No template in Template_sequences.csv for ' + item + 
                   '. Skipping over this file.\n', input_directory)             # Ignore files that do not have templates assigned in Template_sequences.csv and alert the user to this. 

if tidy_mode == 1:                                                              # Checks if Tidy Mode is activated. 
    for item in os.listdir(input_directory):                                    # Loop back through the directory and delete any remaining quality-screened .fasta files. 
        if item.endswith("-hq.fasta"):
            os.remove(item) 

t4 = time.time()
runlog('\nAlignments complete:' + str(t4-t1) + ' seconds elapsed.\n',
       input_directory)                                                         # Print the elapsed time up to this point. 


## Delete old slice files. If these are not removed, a subsequent iteration
## of the slice program will append new values onto the bottoms of the old 
## files. This should run regardless of Tidy Mode. 

for item in os.listdir(input_directory):                                        # Loop through input directory and delete old slice files. 
    if item.endswith('_sliced.txt'):
        if item.rsplit('_',4)[0] in d_templates:
            os.remove(item)


## Slicing alignments to just positions of interest.                            # Inspired by this answer:
                                                                                # https://www.biostars.org/p/302162/
runlog('\nSlicing strings:\n', input_directory)                                 # Alert the user to the current phase of the analysis.

n_sliced = 0                                                                    # Tally number of slice files to be processed. 
                                                                                
for item in os.listdir(input_directory):                                        # Loop through each file in the specified directory.
    if item.endswith('-aligned.txt'):                                           # Opens each file of alignments as read only.
        if item.rsplit('_',4)[0] in d_templates:                                # Check if there is a template sequence assigned for the data file
            slicing(item)
            n_sliced =+ 1                                                       # Increment the tally of slice files.
        else:   
            runlog('No template in Template_sequences.csv for ' + item + 
                   '. Skipping over this file.\n', input_directory)             # Ignore files that do not have templates assigned in Template_sequences.csv and alert the user to this. 
        
t5 = time.time()                                                                # Get current time.
runlog('\nSlicing complete:' + str(t5-t1) + ' seconds elapsed.\n',
       input_directory)                                                         # Print the elapsed time up to this point.

        
## Tallying and blank subtracting winning sequences.
if n_sliced > 0:
    df = pd.DataFrame()                                                         # Creates an empty dataframe.
    for item in os.listdir(input_directory):                                    # Loop through each file in the specified directory.
        if item.endswith('_sliced.txt'):                                        # Checks for files containing sliced data.
            if item.rsplit('_',4)[0] in d_templates:                            # Check if there is a template sequence assigned for the data file
                sample_name = (os.path.basename(item)).rsplit('_',1)[0]         # Identifies the sample name based on the data file.
                with open(item, 'r') as N_file:                                 # Opens the file containing sliced data.
                    N_tallies = {}                                              # Creates an empty dictionary.
                    for read in N_file:                                         # Loops through every slice in the data file.
                        N_tallies[read] = N_tallies.get(read, 0) + 1            # If that slice is already a key in the dictionary, increment the tally by 1 (start at 0).
                    g = pd.DataFrame.from_dict(N_tallies, orient = 'index')     # Import the dictionary of tallied slices as a temporary dataframe.
                    g['sample name'] = str(sample_name)                         # Add the sample name as a column of the temporary dataframe.
                    df = pd.concat([df, g])                                     # Append the temporary dataframe to the main dataframe.
            else:   
                runlog('No template in Template_sequences.csv for ' + item + 
                       '. Skipping over this file.\n', input_directory)         # Ignore files that do not have templates assigned in Template_sequences.csv and alert the user to this. 
elif os.path.exists(input_directory + 'Hognose Results.csv'):
    
    n_sliced = 0
  
df = df.reset_index()                                                           # Creates a default ordinal index instead of using the slices as the index.
df.set_axis(['slice', 'tally','sample name'],axis=1,inplace=True)               # Rename the headers of the dataframe columns.
df = df.replace(r'\s','',regex=True)                                            # Strips whitespace (/s; mainly newlines (\n)) from each row of the dataframe.
print(df.sort_values(by=['tally']))                                             # Print the dataframe sorted by tally. 

if tidy_mode == 1:                                                              # Checks if Tidy Mode is activated. 
    for item in os.listdir(input_directory):                                    # Loop back through the directory and delete any remaining slice files. 
        if item.endswith("_sliced.txt"):
            os.remove(item) 

df.to_csv(input_directory + 'Hognose Results.csv', index=True)                  # Prints the dataframe of results to a .csv file in 'tidy data' format.

if extract_winners == 1:                                                        # Check if the slices should be blanked and ranked automatically.
    export_winners(input_directory, 'Hognose Results.csv', number_of_winners)   # Normalize, blank, and rank sequences.


## Closing remarks.

t_final = time.time()                                                           # Get current time.
runlog('\nCompleted in %i seconds\n' % (t_final - t0) + ('*' * 60) + '\n', 
       input_directory)                                                         # Print that the program has completed and the total amount of time it took.


#______________________________________________________________________________ Program complete notification.
exit_window = tk.Tk()                                                           # Defines the prompt for the program to run on successful completion. 
exit_window.title('Hognose 0.0.27')                                             # Displays the current version of the program as the title.

frame_110 = tk.Frame(master=exit_window, width=200, height=50)                  # Defines the dimensions of the top part of the exit notification.
frame_110.pack()                                                                # Adds this portion to the exit notification. 

lbl_exit = tk.Label(text = '\nCompleted in %i seconds\n\n' % (t_final - t0) +\
    'Result files are at the following directory: ', master=frame_110)          # Adds information about the program completing to the top of the exit notification.
lbl_exit.pack()

txt_exit = tk.Text(master=frame_110, height = 7)                                # Adds a text box for the user to copy the directory containing the results files. 
txt_exit.pack()
txt_exit.insert(1.0 , input_directory)

btn_exit = tk.Button(master=frame_110, text='Exit', command=fxn_exit)           # Adds a button promting the user to exit the program when complete. 
btn_exit.pack()

window.mainloop()                                                               # Adds the exit notification to run as part of the program. 